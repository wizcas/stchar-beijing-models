// 引入CSS
import "./style.css";

// 导入模块
import { CSS_CLASSES } from './css-constants.js';
import { detectCharacterType } from './fields.js';
import {
  createDiv,
  createCollapsibleCard,
  createWomanCardScrollContainer,
  generateCardTitle,
  renderObject
} from './renderer.js';

// Production数据获取函数
async function loadStatusData() {
  const raw = await STscript("/getvar 状态栏");
  return typeof raw === "string" ? JSON.parse(raw) : raw;
}

// 测试数据函数（从外部文件读取）
async function loadTestData() {
  try {
    // 方案1: 如果在HTTP服务器环境下，使用fetch
    if (
      window.location.protocol === "http:" ||
      window.location.protocol === "https:"
    ) {
      const response = await fetch("char-var.json");
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const charData = await response.json();

      // 检查是否存在状态栏字段
      if (!charData["状态栏"]) {
        throw new Error("状态栏字段不存在");
      }

      // 解析状态栏数据
      let statusBarData = charData["状态栏"];
      if (typeof statusBarData === "string") {
        statusBarData = JSON.parse(statusBarData);
      }

      // 清理字段名前缀并返回处理后的数据
      return cleanFieldPrefixes(statusBarData);
    } else {
      // 方案2: 如果是file://协议，提示用户启动HTTP服务器
      throw new Error("请使用HTTP服务器访问此页面，或使用内嵌数据模式");
    }
  } catch (error) {
    console.error("Failed to load char-var.json:", error);
    console.log("提示：请启动本地HTTP服务器，例如：");
    console.log("Python: python -m http.server 8000");
    console.log("Node.js: npx http-server");

    // 直接抛出错误，不使用内嵌数据
    throw error;
  }
}

// 清理字段名前缀的函数
function cleanFieldPrefixes(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => cleanFieldPrefixes(item));
  }

  const cleaned = {};
  for (const [key, value] of Object.entries(obj)) {
    // 清理字段名：移除 $开头到空格的前缀
    const cleanKey = cleanFieldName(key);
    cleaned[cleanKey] = cleanFieldPrefixes(value);
  }

  return cleaned;
}

// 这些函数已移动到renderer.js模块中，这里保留是为了向后兼容
// 实际使用时应该从renderer.js导入

// CSS常量已移动到css-constants.js模块中

// 渲染函数已移动到renderer.js模块中

// 更多渲染函数已移动到renderer.js模块中

// CSS Columns Masonry 布局工厂函数 - 高性能瀑布流布局
function createMasonryGrid(className = CSS_CLASSES.SUBSECTIONS_MASONRY) {
  const masonryContainer = createDiv(className);

  // 配置参数 - 优化为2列布局
  const columnWidth = 350; // 每列最小宽度，适合2列布局
  const maxColumns = 2; // 最大列数限制
  const gap = 16; // 间距

  // 创建masonry布局
  function createMasonryLayout() {
    const gridWidth = masonryContainer.offsetWidth;
    const calculatedColumns = Math.floor(gridWidth / columnWidth) || 1;
    const columns = Math.min(calculatedColumns, maxColumns); // 使用配置的最大列数

    // 设置CSS columns属性
    masonryContainer.style.columnCount = columns.toString();
    masonryContainer.style.columnGap = `${gap}px`;
    masonryContainer.style.display = "block";

    // 清除可能的grid属性
    masonryContainer.style.gridTemplateColumns = "";
    masonryContainer.style.gridTemplateRows = "";

    // 设置所有子项目的样式
    const items = Array.from(masonryContainer.children);
    items.forEach((item) => {
      // 清除可能的grid属性
      item.style.gridRowStart = "";
      item.style.gridColumnStart = "";

      // 设置masonry项目样式
      item.style.breakInside = "avoid";
      item.style.marginBottom = `${gap}px`;

      // 确保有正确的类名
      if (!item.classList.contains("masonry-item")) {
        item.classList.add("masonry-item");
      }
    });
  }

  // 添加项目到masonry
  function addItemToMasonry(itemElement) {
    // 确保项目有正确的类名
    if (!itemElement.classList.contains("masonry-item")) {
      itemElement.classList.add("masonry-item");
    }

    masonryContainer.appendChild(itemElement);

    // 延迟重新布局，确保DOM渲染完成
    setTimeout(() => {
      createMasonryLayout();
    }, 10);
  }

  // 响应式重新布局
  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      createMasonryLayout();
    }, 150);
  }

  // MutationObserver 监听DOM变化
  const observer = new MutationObserver(() => {
    createMasonryLayout();
  });

  // 初始化
  function initialize() {
    // 监听窗口大小变化
    window.addEventListener("resize", handleResize);

    // 监听DOM变化
    observer.observe(masonryContainer, {
      childList: true,
      subtree: true,
    });

    // 初始布局
    setTimeout(() => {
      createMasonryLayout();
    }, 10);
  }

  // 立即初始化
  initialize();

  return {
    container: masonryContainer,
    addItem: addItemToMasonry,
    addItems: (itemElements) => {
      itemElements.forEach((item) => addItemToMasonry(item));
    },
    addItemSmart: addItemToMasonry, // CSS columns会自动优化布局
    relayout: createMasonryLayout,
    forceLayout: () => {
      setTimeout(() => {
        createMasonryLayout();
      }, 50);
    },
    // 清理资源
    destroy: () => {
      window.removeEventListener("resize", handleResize);
      observer.disconnect();
    },
  };
}

// 检测是否应该使用 masonry 布局的函数
function shouldUseMasonryLayout(subsections) {
  // 如果子部分数量大于等于3个，使用 masonry 布局
  return Object.keys(subsections).length >= 3;
}

// 检测滚动容器是否有溢出内容
function checkScrollOverflow(container) {
  if (!container) return false;
  return container.scrollHeight > container.clientHeight;
}

// 更新滚动容器的溢出状态
function updateScrollOverflowState(scrollContainer, contentElement) {
  if (!scrollContainer || !contentElement) return;

  const hasOverflow = checkScrollOverflow(contentElement);

  if (hasOverflow) {
    scrollContainer.classList.add("has-overflow");
  } else {
    scrollContainer.classList.remove("has-overflow");
  }
}

// 创建带滚动检测的女性角色卡片容器
function createWomanCardScrollContainer(contentElement) {
  const scrollContainer = createDiv(CSS_CLASSES.WOMAN_CARD_SCROLL_CONTAINER);
  const contentWrapper = createDiv(CSS_CLASSES.WOMAN_CARD_CONTENT);

  contentWrapper.appendChild(contentElement);
  scrollContainer.appendChild(contentWrapper);

  // 初始检测
  setTimeout(() => {
    updateScrollOverflowState(scrollContainer, contentWrapper);
  }, 100);

  // 监听内容变化
  const observer = new MutationObserver(() => {
    setTimeout(() => {
      updateScrollOverflowState(scrollContainer, contentWrapper);
    }, 50);
  });

  observer.observe(contentWrapper, {
    childList: true,
    subtree: true,
    attributes: true,
  });

  // 监听窗口大小变化
  const resizeHandler = () => {
    setTimeout(() => {
      updateScrollOverflowState(scrollContainer, contentWrapper);
    }, 100);
  };

  window.addEventListener("resize", resizeHandler);

  // 存储清理函数
  scrollContainer._cleanup = () => {
    observer.disconnect();
    window.removeEventListener("resize", resizeHandler);
  };

  return scrollContainer;
}

// 为字段名添加emoji
function addEmojiToFieldName(fieldName) {
  const emoji = emojiMap[fieldName];
  return emoji ? `${emoji} ${fieldName}` : fieldName;
}

// 特定角色类型的字段顺序配置
const fieldOrder = {
  "{{user}}": ["行业等级", "想法", "堕落度", "穿搭", "器材"],
  女人: ["想法", "关系", "外型", "职业", "性爱"],
  关系: ["堕落度", "好感度"],
  外型: ["五官", "发型", "穿搭", "身高", "体重", "三围", "罩杯"],
  职业: ["类型", "层级", "方向", "尺度", "人设"],
  性爱: ["性经验次数", "乳房敏感度", "小穴湿润度", "肛门松弛度"],
};

// 创建通用字段顺序的Set，提高查找性能
const universalFieldOrderSet = new Set(universalFieldOrder);

// 预计算字段顺序的Set，提高查找性能
const fieldOrderSets = {};
for (const [section, fields] of Object.entries(fieldOrder)) {
  fieldOrderSets[section] = new Set(fields);
}

// 检测角色类型的函数
function detectCharacterType(sectionName, sectionData) {
  // 检查是否包含用户特有字段
  const userFields = ["行业等级", "堕落度", "器材"];
  const hasUserFields = userFields.some(
    (field) => sectionData && sectionData.hasOwnProperty(field),
  );

  // 检查是否包含女性角色特有字段
  const womanFields = ["关系", "外型", "职业", "性爱", "昵称", "全名", "姓名"];
  const hasWomanFields = womanFields.some(
    (field) => sectionData && sectionData.hasOwnProperty(field),
  );

  // 检查是否是系统分类
  const systemSections = ["关系", "外型", "职业", "性爱"];
  const isSystemSection = systemSections.includes(sectionName);

  if (
    hasUserFields ||
    sectionName.includes("user") ||
    sectionName.includes("小二")
  ) {
    return "user";
  } else if (isSystemSection) {
    return "system";
  } else if (hasWomanFields || (!hasUserFields && !isSystemSection)) {
    return "woman";
  }

  return "unknown";
}

// 获取字段顺序的函数
function getFieldOrder(sectionName, sectionData = null) {
  // 优先使用精确匹配的特定配置
  if (fieldOrder[sectionName]) {
    return fieldOrder[sectionName];
  }

  // 基于内容检测角色类型
  const characterType = detectCharacterType(sectionName, sectionData);

  switch (characterType) {
    case "user":
      return fieldOrder["{{user}}"];
    case "woman":
      return fieldOrder["女人"];
    case "system":
      // 对于系统分类，尝试使用对应的配置
      if (fieldOrder[sectionName]) {
        return fieldOrder[sectionName];
      }
      return universalFieldOrder;
    default:
      return universalFieldOrder;
  }
}

// 获取字段顺序Set的函数
function getFieldOrderSet(sectionName, sectionData = null) {
  // 优先使用精确匹配的特定配置
  if (fieldOrderSets[sectionName]) {
    return fieldOrderSets[sectionName];
  }

  // 基于内容检测角色类型
  const characterType = detectCharacterType(sectionName, sectionData);

  switch (characterType) {
    case "user":
      return fieldOrderSets["{{user}}"] || new Set(fieldOrder["{{user}}"]);
    case "woman":
      return fieldOrderSets["女人"] || new Set(fieldOrder["女人"]);
    case "system":
      if (fieldOrderSets[sectionName]) {
        return fieldOrderSets[sectionName];
      }
      return universalFieldOrderSet;
    default:
      return universalFieldOrderSet;
  }
}

// 渲染对象（按固定顺序，优化版本）
function renderObject(obj, container, sectionName, level = 0) {
  // 处理特殊字段合并
  const processedObj = processSpecialFields(obj);

  // 获取该部分的字段顺序和Set
  const order = getFieldOrder(sectionName, obj);
  const orderSet = getFieldOrderSet(sectionName, obj);

  // 如果是顶级角色卡片，需要特殊处理子部分的布局
  const characterType = detectCharacterType(sectionName, obj);
  const isCharacterCard =
    level === 0 && (characterType === "user" || characterType === "woman");

  if (isCharacterCard) {
    renderCharacterCard(processedObj, container, sectionName, order, orderSet);
  } else {
    // 普通渲染逻辑
    if (order && orderSet) {
      // 按预定义顺序渲染字段
      for (const fieldKey of order) {
        if (processedObj.hasOwnProperty(fieldKey)) {
          renderFieldByKey(fieldKey, processedObj[fieldKey], container, level);
        }
      }

      // 渲染未在顺序中定义的字段（使用Set进行O(1)查找）
      for (const [key, value] of Object.entries(processedObj)) {
        if (!orderSet.has(key)) {
          renderFieldByKey(key, value, container, level);
        }
      }
    } else {
      // 如果没有预定义顺序，按原始顺序渲染
      for (const [key, value] of Object.entries(processedObj)) {
        renderFieldByKey(key, value, container, level);
      }
    }
  }
}

// 生成卡片标题
function generateCardTitle(sectionName, sectionData) {
  // 使用角色类型检测
  const characterType = detectCharacterType(sectionName, sectionData);

  if (characterType === "woman" && sectionData) {
    // 查找昵称和全名
    const nickname = sectionData["昵称"] || sectionData["nickname"];
    const fullName =
      sectionData["真名"] ||
      sectionData["全名"] ||
      sectionData["姓名"] ||
      sectionData["名字"];

    if (nickname && fullName) {
      return `${nickname} (${fullName})`;
    } else if (nickname) {
      return nickname;
    } else if (fullName) {
      return fullName;
    }
  }
  return sectionName;
}

// 渲染角色卡片（特殊布局）
function renderCharacterCard(obj, container, sectionName, order, orderSet) {
  // 分离直接字段和子部分
  const directFields = {};
  const subsections = {};

  const fieldsToProcess = order || Object.keys(obj);

  for (const fieldKey of fieldsToProcess) {
    if (obj.hasOwnProperty(fieldKey)) {
      const value = obj[fieldKey];
      if (
        typeof value === "object" &&
        value !== null &&
        !Array.isArray(value)
      ) {
        subsections[fieldKey] = value;
      } else {
        directFields[fieldKey] = value;
      }
    }
  }

  // 渲染直接字段
  for (const [key, value] of Object.entries(directFields)) {
    renderFieldByKey(key, value, container, 0);
  }

  // 创建子部分布局容器 - 支持 masonry 和常规网格
  if (Object.keys(subsections).length > 0) {
    // 根据子部分数量决定使用 masonry 还是常规网格布局
    const useMasonry = shouldUseMasonryLayout(subsections);

    let layoutContainer;
    let addItemFunction;

    if (useMasonry) {
      // 使用 CSS Columns Masonry 布局
      const masonryGrid = createMasonryGrid();
      layoutContainer = masonryGrid.container;
      addItemFunction = masonryGrid.addItemSmart;

      // 存储masonryGrid引用，用于后续强制布局
      layoutContainer._masonryGrid = masonryGrid;
    } else {
      // 使用常规网格布局
      layoutContainer = createDiv(CSS_CLASSES.SUBSECTIONS_GRID);
      addItemFunction = (item) => layoutContainer.appendChild(item);
    }

    // 渲染子部分
    for (const [key, value] of Object.entries(subsections)) {
      const cleanKey = cleanFieldName(key);

      // 检查是否是器材对象，如果是则使用特殊渲染
      if (isEquipmentObject(value)) {
        // 器材对象需要特殊处理，创建临时容器
        const tempContainer = createDiv();
        renderEquipmentObject(cleanKey, value, tempContainer);
        // 将器材对象的折叠卡片添加到布局容器
        const equipmentCard = tempContainer.firstChild;
        if (equipmentCard) {
          addItemFunction(equipmentCard);
        }
      } else {
        // 普通子部分渲染 - 使用组件工厂
        const subsectionComponent = createSubsectionComponent(
          cleanKey,
          (contentContainer) => {
            renderObject(value, contentContainer, cleanKey, 1);
          },
        );
        addItemFunction(subsectionComponent);
      }
    }

    container.appendChild(layoutContainer);

    // 如果使用了Masonry布局，在DOM添加后强制重新布局
    if (useMasonry && layoutContainer._masonryGrid) {
      layoutContainer._masonryGrid.forceLayout();
    }
  }
}

// 提取字段渲染逻辑，避免重复代码
function renderFieldByKey(key, value, container, level) {
  const cleanKey = cleanFieldName(key);

  if (typeof value === "object" && value !== null) {
    if (Array.isArray(value)) {
      renderArray(cleanKey, value, container);
    } else if (isEquipmentObject(value)) {
      // 特殊处理器材对象格式 {categoryname: [items...], categoryname2: [items...], ...}

      renderEquipmentObject(cleanKey, value, container);
    } else {
      renderSubsection(cleanKey, value, container, level);
    }
  } else {
    renderField(cleanKey, value, container);
  }
}

// 检查是否为器材对象格式
function isEquipmentObject(obj) {
  // 检查对象的所有值是否都是数组（新格式：{categoryname: [items...]})
  const values = Object.values(obj);
  const keys = Object.keys(obj);

  // 必须有值，且所有值都是数组
  const allValuesAreArrays =
    values.length > 0 && values.every((value) => Array.isArray(value));

  // 检查是否包含器材相关的键名
  const hasEquipmentKeys = keys.some(
    (key) =>
      key.includes("机身") ||
      key.includes("镜头") ||
      key.includes("灯光") ||
      key.includes("配件") ||
      key.includes("其他") ||
      key.includes("设备"),
  );

  const isEquipment =
    allValuesAreArrays && (hasEquipmentKeys || keys.length >= 3);

  return isEquipment;
}

// 更新父级折叠卡片高度的函数
function updateParentCardHeight(element) {
  let current = element;

  // 向上遍历，更新所有展开状态的父级折叠容器
  while (current && current.parentElement) {
    current = current.parentElement;

    // 查找折叠内容容器
    if (
      current.classList &&
      current.classList.contains("collapsible-content")
    ) {
      // 检查是否处于展开状态
      if (current.style.maxHeight && current.style.maxHeight !== "0px") {
        // 重新计算高度
        current.style.maxHeight = current.scrollHeight + "px";
      }
    }
  }
}

// 创建可折叠卡片的通用函数
function createCollapsibleCard(
  title,
  contentElement,
  isInitiallyCollapsed = true,
  customStyles = {},
) {
  const cardDiv = document.createElement("div");
  cardDiv.className =
    customStyles.cardClass ||
    "bg-[var(--color-surface-accent)] border border-[var(--color-border-accent)] rounded-[var(--radius-element)] h-fit shadow-[var(--shadow-element)]";

  // 创建可点击的标题容器（包含padding，整个区域可点击）
  const titleContainer = document.createElement("div");
  titleContainer.className = CSS_CLASSES.COLLAPSIBLE_TITLE;

  const titleDiv = document.createElement("div");
  titleDiv.className = customStyles.titleClass || CSS_CLASSES.SECTION_TITLE;
  titleDiv.textContent = customStyles.useRawTitle
    ? title
    : addEmojiToFieldName(title);

  // 创建折叠指示器
  const collapseIcon = document.createElement("div");
  collapseIcon.className = CSS_CLASSES.COLLAPSE_ICON;
  collapseIcon.textContent = "✕";

  titleContainer.appendChild(titleDiv);
  titleContainer.appendChild(collapseIcon);
  cardDiv.appendChild(titleContainer);

  // 创建可折叠的内容容器
  const collapsibleContent = document.createElement("div");
  collapsibleContent.className =
    "collapsible-content overflow-hidden transition-all duration-200 ease-in-out";
  collapsibleContent.appendChild(contentElement);
  cardDiv.appendChild(collapsibleContent);

  // 添加折叠功能
  let isCollapsed = isInitiallyCollapsed;

  // 重新计算高度的函数
  function recalculateHeight() {
    if (!isCollapsed) {
      collapsibleContent.style.maxHeight =
        collapsibleContent.scrollHeight + "px";

      // 更新滚动溢出状态
      const scrollContainer = collapsibleContent.querySelector(
        ".woman-card-scroll-container",
      );
      const contentWrapper = scrollContainer?.querySelector(
        ".woman-card-content",
      );
      if (scrollContainer && contentWrapper) {
        updateScrollOverflowState(scrollContainer, contentWrapper);
      }
    }
  }

  titleContainer.addEventListener("click", () => {
    isCollapsed = !isCollapsed;

    if (isCollapsed) {
      // 折叠状态：高度为0，图标为"✕"旋转45度
      collapsibleContent.style.maxHeight = "0px";
      collapseIcon.style.transform = "rotate(45deg)";
    } else {
      // 展开状态：高度为内容高度，图标为"✕"不旋转
      recalculateHeight();
      collapseIcon.style.transform = "rotate(0deg)";
    }

    // 更新父级卡片高度 - 立即开始，然后在动画完成后再次更新
    setTimeout(() => {
      updateParentCardHeight(collapsibleContent);
    }, 50); // 立即更新

    setTimeout(() => {
      updateParentCardHeight(collapsibleContent);
      recalculateHeight(); // 动画完成后再次重新计算
    }, 220); // 动画完成后再次更新
  });

  // 监听窗口大小变化
  const resizeHandler = () => {
    setTimeout(() => {
      recalculateHeight();
      updateParentCardHeight(collapsibleContent);
    }, 100);
  };

  window.addEventListener("resize", resizeHandler);

  // 存储清理函数
  cardDiv._cleanup = () => {
    window.removeEventListener("resize", resizeHandler);
  };

  // 设置初始状态
  setTimeout(() => {
    if (isCollapsed) {
      collapsibleContent.style.maxHeight = "0px";
      collapseIcon.style.transform = "rotate(45deg)";
    } else {
      recalculateHeight();
      collapseIcon.style.transform = "rotate(0deg)";
    }
  }, 0);

  return cardDiv;
}

// 渲染器材对象
function renderEquipmentObject(title, obj, container) {
  // 创建器材网格容器
  const equipmentGrid = document.createElement("div");
  equipmentGrid.className = CSS_CLASSES.EQUIPMENT_GRID;

  // 分离"其他"类别和前4类
  const entries = Object.entries(obj);
  const otherEntries = entries.filter(
    ([categoryName]) => categoryName === "其他",
  );
  const regularEntries = entries.filter(
    ([categoryName]) => categoryName !== "其他",
  );

  // 渲染前4类（或所有非"其他"类别） - 重构后使用组件工厂
  regularEntries.forEach(([categoryName, items]) => {
    const itemDiv = createDiv(CSS_CLASSES.EQUIPMENT_ITEM, null, equipmentGrid);
    createDiv(
      CSS_CLASSES.CATEGORY_TITLE,
      addEmojiToFieldName(categoryName),
      itemDiv,
    );
    createTagContainer(items, itemDiv);
  });

  // 渲染"其他"类别（如果存在） - 重构后使用组件工厂
  otherEntries.forEach(([categoryName, items]) => {
    const itemDiv = createDiv(
      CSS_CLASSES.EQUIPMENT_ITEM_FULL,
      null,
      equipmentGrid,
    );
    createDiv(
      CSS_CLASSES.CATEGORY_TITLE,
      addEmojiToFieldName(categoryName),
      itemDiv,
    );
    createTagContainer(items, itemDiv);
  });

  // 使用通用折叠卡片函数
  const collapsibleCard = createCollapsibleCard(title, equipmentGrid, true);
  container.appendChild(collapsibleCard);
}

// 处理特殊字段合并和格式化
function processSpecialFields(obj) {
  const processed = { ...obj };

  // 处理昵称和真名合并
  if (processed["昵称"] && processed["真名"]) {
    const nickname = processed["昵称"];
    const realName = processed["真名"];
    processed["名字"] = `${nickname} (${realName})`;
    delete processed["昵称"];
    delete processed["真名"];
  }

  // 处理三围合并
  if (processed["胸围"] && processed["腰围"] && processed["臀围"]) {
    const bust = processed["胸围"];
    const waist = processed["腰围"];
    const hip = processed["臀围"];
    processed["三围"] = `${bust}-${waist}-${hip} cm`;
    delete processed["胸围"];
    delete processed["腰围"];
    delete processed["臀围"];
  }

  // 处理身高单位
  if (processed["身高"]) {
    processed["身高"] = processed["身高"] + " cm";
  }

  // 处理体重单位
  if (processed["体重"]) {
    processed["体重"] = processed["体重"] + " kg";
  }

  return processed;
}

// 渲染字段 - 重构后使用组件工厂
function renderField(name, value, container) {
  const fieldComponent = createFieldComponent(
    name,
    value,
    Array.isArray(value),
  );
  container.appendChild(fieldComponent);
}

// 渲染子部分 - 重构后使用组件工厂
function renderSubsection(title, obj, container, level) {
  const subsectionComponent = createSubsectionComponent(
    title,
    (contentContainer) => {
      renderObject(obj, contentContainer, title, level + 1);
    },
  );
  container.appendChild(subsectionComponent);
}

// 渲染数组
function renderArray(title, arr, container) {
  // 检查是否为简单的字符串数组（用于标签显示）
  const isSimpleArray = arr.every((item) => typeof item === "string");

  if (isSimpleArray) {
    // 渲染为标签样式的字段 - 重构后使用组件工厂
    const fieldComponent = createFieldComponent(title, arr, true);
    container.appendChild(fieldComponent);
  } else {
    // 复杂数组 - 重构后使用组件工厂
    const subsectionComponent = createSubsectionComponent(
      title,
      (contentContainer) => {
        arr.forEach((item) => {
          const itemDiv = createDiv(
            CSS_CLASSES.ARRAY_ITEM,
            null,
            contentContainer,
          );

          if (typeof item === "object" && item.category && item.items) {
            createDiv(CSS_CLASSES.CATEGORY_TITLE, item.category, itemDiv);
            createTagContainer(item.items, itemDiv);
          } else {
            itemDiv.textContent = item;
          }
        });
      },
    );
    container.appendChild(subsectionComponent);
  }
}

// 初始化页面
async function init() {
  const container = document.getElementById("status-display");

  try {
    // Production: 使用 loadStatusData() 从API获取数据
    // Development: 使用 loadTestData() 从char-var.json获取测试数据
    // const statusData = await loadStatusData();
    const statusData = await loadTestData();
    console.log("【PHOTO】status data", statusData);

    for (const [sectionName, sectionData] of Object.entries(statusData)) {
      // 角色卡片样式配置
      const characterCardStyles = {
        cardClass:
          "bg-[var(--color-surface-primary)] border border-[var(--color-border-subtle)] rounded-[var(--radius-card)] shadow-[var(--shadow-card)]",
        titleClass:
          "text-[var(--color-accent-gold)] text-xl sm:text-lg font-bold tracking-wide flex items-center",
        useRawTitle: true,
      };

      // 如果是"女人"层级，直接展示其子项目
      if (sectionName === "女人") {
        for (const [subSectionName, subSectionData] of Object.entries(
          sectionData,
        )) {
          // 创建角色卡片内容容器
          const characterContent = document.createElement("div");
          characterContent.className = CSS_CLASSES.CHARACTER_CONTENT;
          renderObject(subSectionData, characterContent, subSectionName);

          // 创建带滚动检测的容器
          const scrollContainer =
            createWomanCardScrollContainer(characterContent);

          // 使用通用折叠卡片函数，角色卡片默认折叠
          const collapsibleCard = createCollapsibleCard(
            generateCardTitle(subSectionName, subSectionData),
            scrollContainer,
            true, // 角色卡片默认折叠
            characterCardStyles,
          );

          container.appendChild(collapsibleCard);
        }
      } else {
        // 创建角色卡片内容容器
        const characterContent = document.createElement("div");
        characterContent.className = CSS_CLASSES.CHARACTER_CONTENT;
        renderObject(sectionData, characterContent, sectionName);

        // 使用通用折叠卡片函数，角色卡片默认折叠
        const collapsibleCard = createCollapsibleCard(
          generateCardTitle(sectionName, sectionData),
          characterContent,
          true, // 角色卡片默认折叠
          characterCardStyles,
        );

        container.appendChild(collapsibleCard);
      }
    }
  } catch (error) {
    console.error("Failed to load status data:", error);
    container.innerHTML = `
      <div class="section" style="text-align: center; color: #ff6666;">
        <div class="section-title">数据加载失败</div>
        <div style="margin: 20px; line-height: 1.6;">
          <p>无法读取 char-var.json 文件</p>
          <p style="margin-top: 10px; font-size: 14px; color: #ffaa00;">
            请确保：<br>
            1. char-var.json 文件存在于同一目录<br>
            2. 使用HTTP服务器访问此页面<br>
            3. 文件包含"状态栏"字段
          </p>
          <p style="margin-top: 15px; font-size: 12px; color: #888;">
            启动HTTP服务器：python -m http.server 8000
          </p>
        </div>
      </div>
    `;
  }
}

// 页面加载完成后初始化
document.addEventListener("DOMContentLoaded", init);
